# 敌人 A* 寻路实现方案

## 目标
- 在现有场景中生成敌人实体，能持续朝玩家移动。
- 使用 A* 在导航网格上规划路径，定期重算应对玩家移动和动态障碍。
- 让敌人沿路径平滑移动并处理到达、卡住等边界情况。

## 核心步骤
1. **导航数据准备**
   - 生成/加载导航网格（`NavigationMesh` 或已有 `NavigationGrid`）。确定坐标系与场景尺寸匹配，避免与不可行走区域重叠（地板、高台、斜坡等）。
   - 若使用网格：提供障碍标记（坡体、门体、不可行走方块）。
2. **敌人对象与组件**
   - 添加敌人 `GameObject`：碰撞体（AABB/OBB）、`PhysicsObject`（动态）与渲染网格。
   - 敌人逻辑类：持有目标（玩家）、导航引用、路径点列表、当前位置索引、速度与转向参数。
3. **路径规划（A*）**
   - 使用 `NavigationGrid::FindPath` 或网格等价接口，以敌人当前位置和玩家当前位置为起点终点。
   - 将结果路径转成世界坐标的 waypoint 列表（简化/平滑可选）。
   - 规划周期：每隔固定时间（如 0.5~1s）或玩家超出阈值距离时重算；若寻路失败，延迟重试。
4. **移动控制**
   - 取当前 waypoint，计算方向与距离；在近距离内切换到下一个 waypoint。
   - 施加力/速度朝向方向，限制最大速度并添加简单阻尼；朝向插值朝向运动方向。
   - 到达终点后短暂停留或直接重算路径。
5. **动态障碍与门交互**
   - 若有移动门/方块，更新导航障碍或在路径跟随中进行简单避让：检测前方碰撞，短暂减速并触发重算。
   - 门完全打开/关闭状态可切换可行走区域，必要时重建或切换网格。
6. **卡住检测与恢复**
   - 监测速度过低且路径索引长期不前进时，触发路径重算或小幅随机偏移。
7. **性能与调试**
   - 限制 A* 调用频率；路径点数量可在生成后做折线简化。
   - Debug 可视化：绘制路径线段和当前 waypoint；在调试 HUD 显示状态（巡航、重算、卡住）。

## 数据与参数建议
- 寻路刷新间隔：`0.5s`
- 到达 waypoint 误差：`0.3~0.5m`
- 最大速度：与玩家接近但略低/略高，根据难度调整。
- 力/加速度：与 `PhysicsObject` 质量匹配，避免忽略碰撞。

## 状态机设计（敌人 AI）
- **State: Idle/Patrol**（可选）  
  - 行为：原地待机或在预设点巡逻；周期性检查玩家距离与视野。  
  - 转移：检测到玩家（距离/视锥/射线无阻挡）→ `Chase`。
- **State: Chase**（主要）  
  - 行为：定期 A* 寻路到玩家，沿路径移动。  
  - 转移：  
    - 与玩家距离 < 近战阈值 → `Attack`（若需要）。  
    - 丢失玩家（距离超限或视野被阻挡超过超时）→ 回 `Idle/Patrol`。  
    - 路径连续失败/卡住次数超阈值 → 触发重算或短暂 `Recover` 状态。
- **State: Attack**（可选）  
  - 行为：停下或保持小步移动，触发伤害/动画。  
  - 转移：玩家离开攻击范围 → 回 `Chase`。
- **State: Recover**（可选，用于卡住处理）  
  - 行为：清空路径、随机小幅位移或等待后重算。  
  - 转移：恢复成功 → `Chase`；多次失败可回 `Idle/Patrol`。
- **状态机实现**  
  - 复用现有 `StateMachine`/`State`/`StateTransition`（仓库已有）。  
  - 在敌人控制器中持有状态机实例，`Update(dt)` 调用 `stateMachine->Update(dt)`；每个状态执行对应逻辑（寻路、移动、攻击）。

## 集成点（代码位置提示）
- 敌人生成：`TutorialGame::BuildSlopeScene`（或专用生成函数）。
- 更新逻辑：`TutorialGame::UpdateGame` 中调用敌人控制器的 `Update`。
- 导航：`NavigationGrid`/`NavigationMesh` 加载与缓存，复用现有示例代码。
- Debug 绘制：使用 `Debug::DrawLine` 展示路径。

## 测试场景
- 开门前/后：确保寻路能处理门封闭与开启。
- 玩家静止与快速移动：验证路径重算跟随。
- 推动方块阻挡：敌人减速或绕过，若无法通过则重算路径。
